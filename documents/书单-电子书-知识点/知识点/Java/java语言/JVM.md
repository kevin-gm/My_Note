## Java运行时数据区
Java虚拟机在执行Java程序的过程中，会把管理的内存划分为若干个不同的数据区域。每个区域各有用途，以及创建和销毁时间。根据《Java虚拟机规范(Java SE 7版)》，主要分为以下几个运行时数据区：

线程共享的：

- 堆
- 方法区

线程隔离的：

- 虚拟机栈
- 本地方法栈
- 程序计数器

### 程序计数器
程序计数器，可以看作是当前程序所执行的字节码的行号指示器。

字节码指示器通过改变这个计数器的值来选取需要执行的下一条字节码指令，分支，循环，跳转，异常处理等都需要依赖这个计数器完成。

程序计数器是线程私有的，也就是每个线程都有一个独立的程序计数器。

如果线程执行的是一个Java方法，则程序计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是native方法，则计数器值为空(Undefined)。

程序计数器这个区域是虚拟机规范中唯一一个没有规定任何OutOfMemoryError异常的区域。

### 虚拟机栈
虚拟机栈的是线程私有的，其生命周期与线程相同。

每个方法在执行的同时都会创建一个栈帧(Stack Frame)，用于存储**局部变量表，操作数栈，动态链接，方法出口**等信息。每个方法从调用到执行完成，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表，存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型。
> - 基本数据类型：byte,char,short,int,long,float,double,boolean
> - 对象引用：reference类型，可能是执行一个代表对象的句柄，或其他与此对象相关的位置
> - returnAddress类型：指向了一条字节码指令的地址
> - 64位长度的long和double类型的数据占用2个局部变量表空间(slot)，其余类型只占用一个。

局部变量表所需的内存空间，在编译器完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量表空间是完全确定的，运行期间不会改变局部变量表大小。

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError；

如果虚拟机栈可以动态扩展，且扩展是无法申请到足够的内存，抛出OutOfMemoryError异常。

### 本地方法栈
本地方法栈与虚拟机栈作用类似，本地方法栈是为Native方法服务。

有些虚拟机会将本地方法栈和虚拟机栈合并。

本地方法栈，也会抛出StackOverflowError和OutOfMemoryError

### Java堆
Java堆是被所有线程共享的一块区域，此区域的唯一目的就是存放**对象实例**，几乎所有的对象实例和数组都是在这里分配内存。

Java堆可以处于物理上不连续的空间，只要逻辑上连续即可。

