多个线程 对 共享的 同一个对象 的 同一个实例变量 进行 并发 操作时，可能会出现数据不一致的情况，这就是非线程安全

只有实例变量才可能出现线程安全问题，方法内部的变量是线程独有的，不会有安全问题。

#### synchronized
synchronized关键字的作用是实现线程间的同步。意思是，使用synchronized关键字修饰的代码，同一时刻，只能有一个线程运行改代码，多个线程之间是串行执行的，所以不会有线程安全的问题。

synchronized锁具有可重入性，意思是，同一个线程得到对象锁后，再次请求获得该锁时，可以直接获取。

可重入，支持父子类继承关系。子类的同步方法中，调用父类的同步方法，是可以获得锁的。

当一个线程执行的代码出现异常是，其持有的锁会自动释放

同步 不 具有继承性。父类的同步方法，子类 重写 后，如果不加同步控制，则子类的方法不具有同步特性。

#### synchronized具有以下几种用法

 - 持有对象的锁
	 - 实例方法
	
			class A {
				synchronized void method() {}
			}
	- 同步代码块，使用this作为同步对象

			class A {
				void method() {
					sychronized(this) {}
				}
			}
	- 同步代码块，使用具体对象

			class A {
				void method() {
					sychronized(obj) {}
				}
			}
- 持有类锁
	- 类方法

			class A {
				synchronized static void method() {}
			}
	- 同步代码块，使用某一个class类对象
	
			class A {
				void method() {
					sychronized(B.class) {}
				}
			}

多线程在执行同步代码时，是否会阻塞，关键在于看，同步逻辑所持有的对象监视器是否相同，相同则会阻塞。

比如上述，持有对象锁的三种情况，同时执行时，如果都是某一个具体的A对象，则三个同步方法会阻塞。