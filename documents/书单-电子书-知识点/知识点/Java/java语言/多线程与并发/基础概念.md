#### 原子性
**原子性(Atomicity)**是指一个操作是不可中断的。即使是在多个线程同时执行的时候，多个线程之间互不干扰。

比如，对于一个全局静态变量int i，A和B两个线程分别对其赋值为1和2，那么，i最后的值要么是1，要么是2，每个线程的赋值操作不可被中断。

注意：在32位虚拟机上，long型的读写不是原子性的，因为long是64位的，需要两个32位，读和写都可能串位。

#### 可见性
**可见性(Visibility)**是指当一个线程修改了某一个共享变量的值时，其他线程是否能够立即知道这个修改，读到最新的值。

串行程序不会存在可见性的问题，但是在并行程序中，就可能存在问题。

首先，为了优化CPU的运行速度，CPU是有缓存的，对于多核CPU，每个CPU上运行的程序，对于共享变量的值优化可能都是在各自CPU的缓存，多个CPU之间无法感知对方的修改；即使是单核CPU，多线程的读写，可能读到的是缓存的内容，但是实际的值已经被其他线程修改。

指令重排

- 指令重排并不是一定会发生
- 即使发生指令重排，也会保证串行语义的一致性，但是不保证多线程语义的一致性。

一条指令的执行大致分为以下几个步骤：

- 取指 (IF)
- 译码和取寄存器操作数 (ID)
- 执行或者有效地址计算 (EX)
- 存储器访问 (MEM)
- 写回 (WB)

哪些指令不能重排：Happen-Before原则

- 程序顺序原则：一个线程内保证语义的串行性。
- volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性
- 锁规则：解锁(unlock)必然发生在随后的枷锁(lock)前
- 传递性：A先于B，B先于C，则A必然先于C
- 线程的start()方法先于它的每一个动作。
- 线程的所有操作先于线程的终结(Thread.join())
- 线程的中断(interrupt())，先于被中断线程的代码
- 对象的构造函数执行、结束先于finalize()方法

编译器优化

#### 有序性
**有序性(Ordering)**，我们通常习惯于程序代码顺序执行，但是在发生指令重排后，实际执行的指令顺序与原指令顺序未必一致。