
传统的单体结构是所有的业务逻辑在同一个项目，集中部署，当出现瓶颈时，一般进行横向扩展，就是添加机器，项目的多服务器部署形成的就是集群。

理论上集群可以解决性能瓶颈，因为机器可以无限扩展。但是，一味的添加机器并不是最优的，因为无法达到资源的合理利用。比如一旦有bug，必须整个项目进行部署，会影响其他正常的业务、项目中业务可能有IO密集型和CPU密集型的区别、业务读写占比不同、非核心业务会抢占核心业务资源等等。此时会将单体项目进行服务化。

个人的理解是，单体结构服务化后，部署形成的就是分布式。

## 基本概念
### 分布式事务

服务化后，每个服务可能都有自己独立的数据库，一个业务流程中可能涉及多个数据库操作，比如下单操作中涉及到订单服务和库存服务。这种多数据库的全局事务管理，就是分布式事务。

> A distributed transaction is a database transaction in which two or more network hosts are involved. Usually, hosts provide transactional resources, while the transaction manager is responsible for creating and managing a global transaction that encompasses all operations against such resources. Distributed transactions, as any other transactions, must have all four ACID (atomicity, consistency, isolation, durability) properties, where atomicity guarantees all-or-nothing outcomes for the unit of work (operations bundle)

分布式事务涉及不同的独立物理主机，每台机器都不知道其他机器本地事务的执行情况，所以此时需要引入一个中间协调者。

### CAP定理

CAP是指对于同一个分布式计算系统来说，不能同时满足以下三点：

- 一致性(Consistence)：统一时刻，所有节点的数据都是最新的
- 可用性(Availability)：每次请求都能获取到非错的响应(但是不保证获取的数据为最新数据)
- 分区容错性(Partition tolerance)：系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择

### XA规范
XA(X/Open)规范是由Open Group提出的分布式事务处理(DTP)模型，是一种2PC规范，该模型已成为事务模型组件行为的事实标准。Oracle、Mysql等都有实现XA规范的接口

XA的核心概念是TM(事务管理器)和RM(资源管理器)，一个TM管理和协调一个或多个RM。

### 2PC
2PC，即两阶段提交，它分为以下两个阶段:

- 第一阶段：准备阶段，事务协调器要求每个涉及到事务的资源管理器预提交(precommit)此操作，并反映是否可以提交，此时资源管理器会执行事务操作，但是不提交。
	- 协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。
	- 参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）
	- 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。
- 第二阶段：提交阶段，事务协调器要求每个资源管理器提交数据。
	- 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息
	- 否则，发送提交(Commit)消息
	- 参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)

二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个缺点：

1. 同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
2. 单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）
3. 数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。
4. 二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

### 3PC

## 简单实现
### 基于2PC
2PC，其实现是XA规范，J2EE标准里面的实现是JTA，但是需要比如JBOSS之类的容器支持，所以使用第三方库 ```Atomikos```

